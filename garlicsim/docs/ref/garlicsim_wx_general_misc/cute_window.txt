..
   Copyright 2009-2011 Ram Rachum. This work is licensed under a Creative
   Commons Attribution-ShareAlike 3.0 Unported License, with attribution to
   "Ram Rachum at cool-rr.com" including link. The license may be obtained
   at http://creativecommons.org/licenses/by-sa/3.0/

.. _ref-garlicsim_wx_general_misc-cute_window:

===========================================================================================================
:class:`CuteWindow <garlicsim_wx.widgets.general_misc.cute_window.CuteWindow>`: An improved wxPython window
===========================================================================================================

:class:`CuteWindow <garlicsim_wx.widgets.general_misc.cute_window.CuteWindow>`
is a wxPython window which subclasses from :class:`wx.Window` and adds a few
useful functionalities on top of it.

Each section in this document will explain a feature of :class:`CuteWindow
<garlicsim_wx.widgets.general_misc.cute_window.CuteWindow>` and how to use it.


Binding event handlers by name
==============================

The traditional way of binding events in wxPython is by calling
:meth:`self.Bind <wx.Window.Bind>`. This can be too verbose, and result in more
bloated constructors for your widgets. To remedy this, :class:`CuteWindow
<garlicsim_wx.widgets.general_misc.cute_window.CuteWindow>` allows binding
event handlers automatically by their name. Since you probably name your event
handlers according to which event they handle, we might as well use that name
instead of requiring you to call :meth:`self.Bind <wx.Window.Bind>` many times
in your widget's ``__init__``.

To bind event handlers by name, call ``self.bind_event_handlers(window_type)``
where ``window_type`` is the class of your window. (Typically the class in
whose ``__init__`` you're doing the binding.)

Example::

    import wx.lib.buttons    
    
    from garlicsim_wx.widgets.general_misc.cute_window import CuteWindow
    
    
    class MyWidget(CuteWindow):
    
        def __init__(self, parent):
            CuteWindow.__init__(self, parent)
            self.ok_button = wx.lib.buttons.GenButton(self, label='Press me')
            self.bind_event_handlers(MyWidget)
    
        def _on_key_down(self, event):
            pass
            # Handler for `wx.EVT_KEY_DOWN`. Do whatever you want here.
    
        def _on_set_focus(self, event):
            pass
            # Handler for `wx.EVT_SET_FOCUS`. Do whatever you want here.
    
        def _on_ok_button(self, event):
            pass
            # Handler for `self.ok_button` being pressed. Do whatever you want
            # here.
    
        def _on_ok_button__context_menu(self, event):
            pass
            # Handler for `self.ok_button` getting a context menu command. Do
            # whatever you want here.
            

There are three different kinds of usage in the example above:

- **Binding to component.** When ``_on_ok_button`` is encountered, a search is
  made for ``self.ok_button``, and because it exists, we bind to the default
  event for this kind of widget: :data:`wx.EVT_BUTTON`.
  
- **Binding to event type.** When ``_on_key_down`` is encountered, we bind to the
  :data:`wx.EVT_KEY_DOWN` event.
  
- **Nested bind.** When ``_on_ok_button__context_menu`` is encountered, we bind
  to the :data:`wx.EVT_CONTEXT_MENU` event with a ``source`` of
  ``self.ok_button``, i.e. the handler will be invoked when right-clicking on the
  button. (Or pressing the menu key, or :kbd:`Shift-F10` on the keyboard with
  the button in focus.)

            
            
Using different naming conventions
----------------------------------

Not everyone uses the same naming convention for their event handlers. Some
people prefer ``_on_mouse_events`` while others prefer ``OnMouseEvents``.
Fortunately, the :class:`CuteWindow
<garlicsim_wx.widgets.general_misc.cute_window.CuteWindow>` class allows you to
specify which kind of naming scheme you'd like to use by defining a
:attr:`._BindSavvyWindowType__name_parser
<garlicsim_wx.widgets.general_misc.cute_window.CuteWindow._BindSavvyWindowType__name_parser>`
attribute on your window class. What you put in that attribute is a
:class:`NameParser
<garlicsim_wx.widgets.general_misc.cute_window.bind_savvy_window.name_parser.NameParser>`
instance that you can customize.

:class:`NameParser
<garlicsim_wx.widgets.general_misc.cute_window.bind_savvy_window.name_parser.NameParser>`
lets you set which types of case-styles you want to accept (lower-case and/or
camel-case) and how many leading underscores event handlers will have. For both
of these you may set either a single option or a collection of options that
will be acceptable. For example, you can choose to accept both lower-case and
camel-case event handlers with either 0 or 2 preceding underscores.

Example::

    import wx.lib.buttons

    from garlicsim_wx.widgets.general_misc.cute_window import CuteWindow
    from garlicsim_wx.widgets.general_misc.cute_window.bind_savvy_window \
                                       import name_parser as name_parser_module

                     
    class MyWidget(CuteWindow):
        
        _BindSavvyWindowType__name_parser = name_parser_module.NameParser(
            name_parser_module.CamelCase,
            n_preceding_underscores_possibilities=(0, 2)
        )
            
        def __init__(self, parent):
            CuteWindow.__init__(self, parent)
            self.OkButton = wx.lib.buttons.GenButton(self, label='Press me')
            self.bind_event_handlers(MyWidget)
    
        # Example of 0 preceding underscores:
        def OnKeyDown(self, event):
            pass
            # Handler for `wx.EVT_KEY_DOWN`. Do whatever you want here.
    
        # Example of 2 preceding underscores:
        def __OnSetFocus(self, event):
            pass
            # Handler for `wx.EVT_SET_FOCUS`. Do whatever you want here.
    
        def OnOkButton(self, event):
            pass
            # Handler for `self.OkButton` being pressed. Do whatever you want
            # here.
    
        # Example of nested bind:
        def __OnOkButton_ContextMenu(self, event):
            pass
            # Handler for `self.OkButton` getting a context menu command. Do
            # whatever you want here.


Binding to events from different modules
----------------------------------------

Most of the events we bind to, such as :data:`wx.EVT_KEY_DOWN` or
:data:`wx.EVT_PAINT`\, are in the :mod:`wx` namespace. But sometimes we want to
bind to events that are in other modules. Fortunately, the :class:`CuteWindow
<garlicsim_wx.widgets.general_misc.cute_window.CuteWindow>` class allows us to
do that while still using automatic binding.

There are two approaches to binding to events defined outside of :mod:`wx`\:

1. Put the desired event in the namespace of your widget class. This can
   be done either by *defining* the event in that module or by *importing* the
   event from another module into that module. Or,
 
2. Give your widget class an :attr:`.event_modules
   <garlicsim_wx.widgets.general_misc.cute_window.CuteWindow.event_module>`
   attribute. That attribute should be a module (or a list of modules, or
   actually namespaces) in which events will be searched.
   

:attr:`freezer <garlicsim_wx.widgets.general_misc.cute_window.CuteWindow.freezer>`
==================================================================================

todo: This section is not written yet.


:meth:`create_cursor_changer <garlicsim_wx.widgets.general_misc.cute_window.CuteWindow.create_cursor_changer>`
==============================================================================================================

todo: This section is not written yet.


:meth:`add_accelerators <garlicsim_wx.widgets.general_misc.cute_window.CuteWindow.add_accelerators>`
====================================================================================================

todo: This section is not written yet.

